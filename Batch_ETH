from web3 import Web3
from eth_account import Account
from colorama import Fore, Style, init

# Initialize colorama for colored console output
init(autoreset=True)

# Configuration: Sepolia Testnet RPC
SEPOLIA_RPC_URL = 'Fill your RPC'
TARGET_ADDRESS = 'Find your address'

# Initialize Web3 connection
w3 = Web3(Web3.HTTPProvider(SEPOLIA_RPC_URL))

# Check if the connection to Sepolia testnet is successful
if not w3.is_connected():
    print(Fore.RED + "Error: Failed to connect to the Sepolia testnet.")
    exit(1)

# Manual conversion function for Wei to Ether
def wei_to_ether(wei):
    return wei / 10**18  # 1 Ether = 10^18 Wei

# Function to load private keys from file
def load_private_keys(file_path):
    with open(file_path, 'r') as f:
        return [line.strip() for line in f.readlines() if line.strip()]

# Function to save remaining private keys back to the file
def save_private_keys(file_path, private_keys):
    with open(file_path, 'w') as f:
        for key in private_keys:
            f.write(key + '\n')

# Function to calculate max ETH to send from account balance
def calculate_max_eth_to_send(balance, gas_price, gas_limit):
    # The total gas fee is gas_price * gas_limit
    gas_fee = gas_price * gas_limit
    # The maximum ETH to send is balance - gas_fee
    max_eth_to_send = balance - gas_fee
    return max_eth_to_send, gas_fee

# Function to send ETH from a given account
def send_eth_from_private_key(private_key, target_address, remaining_keys):
    # Validate the target address before sending
    if not Web3.is_checksum_address(target_address):
        print(Fore.YELLOW + f"Address {target_address} is not checksummed. Converting to checksum format.")
        target_address = Web3.to_checksum_address(target_address)

    account = Account.from_key(private_key)
    print(Fore.GREEN + f"Sending from: {account.address}")
    
    # Check the balance of the account
    balance = w3.eth.get_balance(account.address)
    balance_in_ether = wei_to_ether(balance)  # Use the manual conversion
    print(Fore.GREEN + f"Balance of {account.address}: {balance_in_ether} ETH")
    
    # If the balance is zero, remove the private key and skip
    if balance == 0:
        print(Fore.RED + f"Wallet {account.address} has a zero balance. Removing private key.")
        remaining_keys.remove(private_key)
        return

    # Get current gas price
    gas_price = w3.eth.gas_price
    
    # Set gas limit (standard for ETH transfer)
    gas_limit = 21000
    
    # Calculate the maximum amount of ETH we can send, accounting for gas fees
    max_eth_to_send, gas_fee = calculate_max_eth_to_send(balance, gas_price, gas_limit)
    
    # Ensure there's enough balance to send at least some ETH
    if max_eth_to_send <= 0:
        print(Fore.RED + "Insufficient balance to cover gas fees. Removing private key.")
        remaining_keys.remove(private_key)
        return
    
    print(Fore.YELLOW + f"Sending {wei_to_ether(max_eth_to_send)} ETH to {target_address}")
    print(Fore.YELLOW + f"Gas Fee: {wei_to_ether(gas_fee)} ETH")
    
    # Get nonce (transaction count for the sender address)
    nonce = w3.eth.get_transaction_count(account.address)

    # Create transaction dictionary
    tx = {
        'nonce': nonce,
        'to': target_address,  # Use the validated and checksum version of the target address
        'value': int(max_eth_to_send),  # Ensure the value is in Wei
        'gas': gas_limit,  # Standard gas for simple ETH transfer
        'gasPrice': gas_price,  # Current gas price
        'chainId': 11155111,  # Chain ID for Sepolia testnet
    }

    # Sign the transaction with the private key
    signed_tx = w3.eth.account.sign_transaction(tx, private_key)

    # Send the raw transaction
    try:
        tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)  # Corrected to raw_transaction
        print(Fore.GREEN + f"Transaction sent! Hash: {Web3.to_hex(tx_hash)}")
        remaining_keys.remove(private_key)  # Remove the key after a successful transaction
    except Exception as e:
        print(Fore.RED + f"Error sending transaction: {e}")
        remaining_keys.remove(private_key)  # Remove the key if there's an error

# Load private keys from the file
file_path = 'private_keys.txt'
private_keys = load_private_keys(file_path)
remaining_keys = private_keys.copy()  # Copy of the keys to modify while iterating

# Loop through each private key and send ETH
for private_key in private_keys:
    try:
        send_eth_from_private_key(private_key, TARGET_ADDRESS, remaining_keys)
    except Exception as e:
        print(Fore.RED + f"Error sending transaction from {private_key}: {e}")

# After processing all keys, save the remaining keys back to the file
save_private_keys(file_path, remaining_keys)
